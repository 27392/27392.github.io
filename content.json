{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2020-06-30T11:06:46.763Z","updated":"2020-06-30T11:06:46.763Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2020-06-30T11:06:46.763Z","updated":"2020-06-30T11:06:46.763Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-06-30T11:06:46.763Z","updated":"2020-06-30T11:06:46.763Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-06-30T11:06:46.763Z","updated":"2020-06-30T11:06:46.763Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-30T11:06:46.763Z","updated":"2020-06-30T11:06:46.763Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaDate与JavaTime互操作","slug":"JavaDate与JavaTime互操作","date":"2020-06-30T18:27:33.000Z","updated":"2020-06-30T11:06:46.763Z","comments":true,"path":"2020/06/30/JavaDate与JavaTime互操作/","link":"","permalink":"http://yoursite.com/2020/06/30/JavaDate%E4%B8%8EJavaTime%E4%BA%92%E6%93%8D%E4%BD%9C/","excerpt":"","text":"类 遗留类 转换到遗留类 转换自遗留类 Instant java.util.Date Date.form(instant) data.toInstant() ZonedDateTime java.util.GregorianCalendar GregorianCalendar.form(zonedDateTime) gregorianCalendar.toZonedDateTime() Instant java.sql.Timestamp Timestamp.form(instant) timestamp.toInstant() LocalDateTime java.sql.Timestamp Timestamp.valueOf(localDateTime) timestamp.toLocalDateTime() LocalDate java.sql.Date Date.valueOf(localDate) data.toLocalDate() LocalTime java.sql.Time Time.valueOf(localDataTime) time.toLocalTime() DateTimeFormatter java.text.DateFormat dateTimeFormatter.toFormat() 无 ZoneId java.util.TimeZone Timezone.getTimeZone(zoneId) timeZone.toZoneId() Instant java.not.file.attribute.FileTime FileTime.from(instant) fileTime.toInstant()","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-06-30T11:06:46.763Z","updated":"2020-06-30T11:06:46.763Z","comments":true,"path":"2020/06/30/hello-world/","link":"","permalink":"http://yoursite.com/2020/06/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"SpringSecurity认证流程","slug":"SpringSecurity认证流程","date":"2020-06-23T13:33:10.000Z","updated":"2020-06-30T11:06:46.763Z","comments":true,"path":"2020/06/23/SpringSecurity认证流程/","link":"","permalink":"http://yoursite.com/2020/06/23/SpringSecurity%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B/","excerpt":"","text":"","categories":[],"tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://yoursite.com/tags/SpringSecurity/"}]},{"title":"test3","slug":"test3","date":"2020-06-23T11:36:33.000Z","updated":"2020-06-30T11:06:46.763Z","comments":true,"path":"2020/06/23/test3/","link":"","permalink":"http://yoursite.com/2020/06/23/test3/","excerpt":"","text":"CentOS安装Nginx并配置HTTPS服务器环境: CentOS7 nginx版本: 1.16.0 安装Nginx安装依赖 安装nginx需要先将官网下载的源码进行编译,编译依赖gcc环境 script1yum install gcc-c++ 2.PCRE(Perl Compatible Regular Expressions) 是一个Perl库,包括perl兼容的正则表达式库.nginx的http模块使用pcre来解析正则表达式,所以需要安装pcre库,pcre-devel是使用pcre开发的一个二次开发库,nginx也需要此库 script1yum install -y pcre pcre-devel` 3.zlib库提供了很多种压缩和解压缩的方式,nginx使用zlib对http包的内容进行gzip script1yum install -y zlib zlib-devel 4.OpenSSL是一个强大的安全套接字层密码库,囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议,并提供丰富的应用程序供测试或其它目的使用. nginx不仅支持http协议,还支持https(即在ssl协议上传输http) script123456789101112131415161718192021yum install -y openssl openssl-devel``` ### 下载 [Nginx 官网](https://nginx.org/en/download.html)```shell scriptwget -c https://nginx.org/download/nginx-1.16.0.tar.gz``` &lt;details&gt; &lt;summary&gt;参数含义&lt;/summary&gt; - `-c` 断点续传&lt;/details&gt;### 解压```shell scripttar -zxvf nginx-1.16.0.tar.gz 参数含义 -z :是否同时具有gzip的属性，即是否需要用gzip压缩 -x :从归档文件中解析文件 -v :压缩过程中显示文件 -f :使用文件名 配置进入文件 script1cd nginx-1.16.0 配置文件信息 普通配置不需要配置HTTPS script1./configure 如果需要配置HTTPS则执行 script1./configure --with-http_ssl_module 编译安装script123makemake install 设置开机自动script123cd /lib/systemd/systemvim nginx.service 将以下文本复进文件中保存即刻 12345678910111213[Unit]Description&#x3D;nginxAfter&#x3D;network.target[Service]Type&#x3D;forkingExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginxExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reloadExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s quitPrivateTmp&#x3D;true[Install]WantedBy&#x3D;multi-user.target 命令详情 描述 命令 设置开机自启动 systemctl enable nginx.service 停止开机自启动 systemctl disable nginx.service 启动Nginx服务 systemctl start nginx.service 停止Nginx服务 systemctl stop nginx.service 重新启动服务 systemctl restart nginx.service 查看服务当前状态 systemctl status nginx.service 参考资料centos安装部署Nginx,并配置https Nginx+Center OS 7.2 开机启动设置 配置HTTPSHTTPS呢使用Let’s Encrypt的免费证书 借助acme.sh这个项目来帮助我们生产证书 生产HTTPS证书安装 acme.sh script1curl https://get.acme.sh | sh 创建一个alias方便使用(可不用) script1alias acme.sh=~/.acme.sh/acme.sh` 配置DNS,这里我使用的是阿里云的,因为我的域名本身就是在阿里云 script123456789export Ali_Key=\"xxxxxxxxxxx\"export Ali_Secret=\"xxxxxxxxxxxxxxxxxxx\"``` 生成通配符证书```shell scriptacme.sh --issue --dns dns_ali -d 你的主域名 -d *.你的主域名 具体例子 script1acme.sh --issue --dns dns_ali -d haohaoli.cn -d *.haohaoli.cn 将证书配置到Nginx移动证书 script12345678# 创建证书存放的位置mkdir /usr/local/nginx/ssl# 移动证书acme.sh --install-cert -d 你的主域名 \\--key-file /usr/local/nginx/ssl/你的主域名.key \\--fullchain-file /usr/local/nginx/ssl/fullchain.cer \\--reloadcmd \"systemctl reload nginx.service\" 具体例子 script1234acme.sh --install-cert -d haohaoli.cn \\--key-file /usr/local/nginx/ssl/haohaoli.key \\--fullchain-file /usr/local/nginx/ssl/fullchain.cer \\--reloadcmd \"systemctl reload nginx.service\" 修改nginx配置文件 script1vim /usr/local/nginx/conf/nginx.conf 找到server为443端口位置 123456789101112131415161718server &#123; listen 443 ssl; server_name www域名 你的主域名; ssl_certificate &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;ssl&#x2F;fullchain.cer; ssl_certificate_key &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;ssl&#x2F;你的主域名.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location &#x2F; &#123; root html; index index.html index.htm; &#125;&#125; 例如 123456789101112131415161718server &#123; listen 443 ssl; server_name www.haohaoli.cn haohaoli.cn; ssl_certificate &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;ssl&#x2F;fullchain.cer; ssl_certificate_key &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;ssl&#x2F;haohaoli.cn.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location &#x2F; &#123; root html; index index.html index.htm; &#125;&#125; 配置http请求转发为https请求,在server为80的server_name下添加: 1return 301 https:&#x2F;&#x2F;$server_name$request_uri; 最后重启加载nginx配置文件 systemctl reload nginx.service 参考资料快速签发 Let’s Encrypt 证书指南 利用 acme.sh 获取网站证书并配置https访问 acme.sh acme.sh-DNS API","categories":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/categories/nginx/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"test","slug":"test","date":"2020-06-23T10:41:13.000Z","updated":"2020-06-30T11:06:46.763Z","comments":true,"path":"2020/06/23/test/","link":"","permalink":"http://yoursite.com/2020/06/23/test/","excerpt":"","text":"Java 核心技术 卷I - 第九章Java集合框架 主要接口在上面可以看到两个接口Collection和Map CollectionCollection接口它包含了集合的基本操作和属性 主要有三个分支 List(有序集合) Set(不包含重复元素的集合) Queue(队列) Map而Map接口则是映射(映射用来存放键/值对) 抽象类 (Abstract…) AbstractCollection 实现了Collection接口的部分功能 AbstractList 实现了List接口的部分功能 AbstractSequentialList 个人理解是链表的超类,存在这个类是为了和数组集合区分开,因为数组集合支持随机访问RandomAccess AbstractQueue 实现了Queue接口的部分功能 AbstractSet 实现了Set接口的部分功能 AbstractMap 实现了Map接口的部分功能 正如之前在第五章所说的抽象类一样,我们可以将一些通用的方法及与放在超类中 AbstractList中实现了List中部分方法,直接继承AbstractList拓展起来更方便 如果我们创建自己的List那么就不用从List接口开始并实现其中的全部方法,只需从AbstractList继承,然后执行一些创建新类必须的工作 Iterable(标识迭代器接口)迭代器是用来遍历集合的工具,它也是一种设计模式 通过Iterable接口可以获取Iterator对象通过他来对象集合进行遍历 而Collection继承了Iterator接口,也就是说所有实现Collection的类都可以使用Iterator遍历器去遍历 主要实现(归类) 集合类型 描 述 ArrayList 一种可以动态增长和缩减的索引序列 LinkedList 一种可以在任何位置进行高效地插人和删除操作的有序序列 ArrayDeque 一种用循环数组实现的双端队列 HashSet 一种没有重复元素的无序集合 TreeSet 一种有序集 EnumSet 一种包含枚举类型值的集 LinkedHashSet 一种可以记住元素插人次序的集 PriorityQueue 一种允许高效删除最小元素的集合 HashMap 一种存储键 / 值关联的数据结构 TreeMap 一种键值有序排列的映射表 EnumMap 一种键值属于枚举类型的映射表 LinkedHashMap 一种可以记住键 / 值项添加次序的映射表 WeakHashMap 一种其值无用武之地后可以被垃圾回收器回收的映射表 IdentityHashMap 一种用==而不是用equals比较键值的映射表 Collection接口 在Java类库中,集合类的根接口是Collection接口 迭代器Iterator接口包含四个方法 1234567891011121314public interface Iterator&lt;E&gt; &#123; // 如果存在可访问的元素,返回true boolean hasNext(); // 返回将要访问的下一个对象.如果已经到达了集合的尾部,将抛出一个 NoSuchElementException E next(); // 删除上次访问的对象.这个方法必须紧跟在访问一个元素之后执行.如果上次访问之后,集合已经发生了变化,这个方法将抛出一个 IllegalStateException default void remove(); // jdk8 遍历 default void forEachRemaining(Consumer&lt;? super E&gt; action);&#125; 通过反复调用next方法可以逐个访问集合中的每个元素. 但是到达了集合的末尾,next方法将抛出一个NoSuchElementException异常 因此需要在调用next之前调用hasNext方法.如果迭代器对象还有多个供访问的元素,这个方法就返回true 如果想查看集合中的所有元素,就请求一个迭代器,并在hasNext返回true时反复的调用next方法 123while (iterator.hasNext())&#123; System.out.println(iterator.next());&#125; 用for each循环可以更加简练的表示同样的循环操作 123for (Integer integer : collection) &#123; System.out.println(integer);&#125; 编译器简单地将for each循环翻译为带有迭代器的循环 for each循环可以与任何实现了Iterable接口的对象一起工作,这个接口只包含一个方法 123public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator();&#125; Collection接口扩展了Iterable接口.因此对于标准库中的任何集合都可以使用for each循环 也就是说for each只是一个语法糖,最后还是会翻译成迭代器的写法,同时扩展了Iterable接口的类都可以使用for each循环 在JDK8中,可以调用forEachRemaining方法来完成遍历 1iterator.forEachRemaining(System.out::println); forEachRemaining方法内部也是同样的在next前调用hasNext 12345default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next());&#125; 注意: 元素被访问的顺序取决于集合的类型 如果对ArrayList进行迭代,迭代器将从索引0开始,每迭代一次,索引值加1 然而,如果是访问HashSet中的元素,每个元素将会按照某种随机的次序出现. 虽然可以确定在迭代过程中能够遍历到集合中的所有元素,但却无法预知元素被访问的次序 这对计算总和或统计符合某个条件的元素个数这类与顺序无关的操作来说并不是什么问题 remove方法则是删除上次调用next方法时返回的元素 1234while (iterator.hasNext())&#123; iterator.next(); iterator.remove(); // 如果在调用remove之前没有调用next则会抛出异常,且不能多次删除&#125; next方法和remove方法的调用具有互相依赖性 如果调用remove之前没有调用next是不合法的,如果这样做将会抛出一个IllegalStateException异常 如果想要删除相邻的元素,不能多次调用remove方法 可以将next方法理解为是一个指针,初始化时指向一个不存在的位置,每当调用一次则移动指针到下一个位置 书上说,可以将next方法与Inputstream.read方法看做等效 从数据流中读取一个字节,就会自动的”消耗掉”这个字节,下一次调用read将会消耗并返回输入的下一个字节 用同样的方法,反复调用next方法就可以读取集合中所有的元素 ListIterator接口 ListIterator接口继承了Iterator接口,提供了专门操作List的方法,也就是说ListIterator是为List所特有的 ListIterator接口在Iterator接口的基础上增加如下方法 1234567891011121314151617181920public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; // 当反向迭代列表时,还有可供访问的元素,返回true boolean hasPrevious(); // 获取之前的元素 E previous(); // 返回下一次调用 next 方法时将返回的元素索引 int nextIndex(); // 返回下一次调用 previous 方法时将返回的元素索引 int previousIndex(); // 用新元素取代 next 或 previous 上次访问的元素.如果在 next 或 previous 上次调用之后列表结构被修改了,将抛出一个 IllegalStateException void set(E e); // 在当前位置前添加一个元素 void add(E e);&#125; ListIterator接口增加了添加元素,设置元素,反向遍历,获取当前位置等功能 而在List接口中提供了两种获取ListIterator的方法 12345678910public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; // 返回一个列表迭代器,以便用来访问列表中的元素 ListIterator&lt;E&gt; listIterator(); // 返回一个列表迭代器,以便用来访问列表中的元素,这个元素是第一次调用 next 返回的给定索引的元素 ListIterator&lt;E&gt; listIterator(int index); ...&#125; 具体的实现ListList: 有序集合(也称为序列).List接口在Collection接口的基础上添加了大量的方法 使得可以精确地控制每个元素在列表中的插入位置. 用户可以通过其整数索引(在列表中的位置)访问元素,并搜索列表中的元素 List接口下有两种类型的实现 基于数组的ArrayList、Vector ArrayList其底层维护一个数组.在操作删除或者添加操作时,具有自动调节数组容量的功能 Vector与ArrayList同理,它们的区别是 是否线程安全 扩容大小 ArrayList 线程不安全 1.5倍 Vector 线程安全 2倍 在Java老版本中,使用Vector实现动态数组.不过ArrayList更有效,所以一般还是使用ArrayList 数组在内存中是顺序存储,因此可以很好地实现逻辑上的顺序表 既不能打乱元素的储存顺序,也不能跳过某个储存单元进行储存 基于链表的linkedList 尽管数组在连续的存储位置上存放对象引用,但是链表却将每个对象放在独立的节点中,每个节点还存放着序列中下一个节点的引用 在Java语言中所有的链表实际上都是双向链表,(即每个节点还存放在指向前驱节点的引用) 所以linkedList也是双向链表 数组在内存中顺序存储,而链表在内存中则是随机存储,链表将每一个节点分布在内存不同的位置,依靠next指针关联 这样可以灵活的利用零散的碎片空间 数组VS链表 数组和链表都属于线性数据结构 查询 更新 插入 删除 数组 O(1) O(1) O(n) O(n) 链表 O(n) O(1) O(1) O(1) 从表格中可以看出,数组的优势在于能够快速定位元素,对于读操作多、写操作少的场景来说,用数组更合适 相反地,链表的优势在于能够灵活的进行插入和删除操作,如果需要在尾部频繁插入、删除元素,用链表更合适 散列表散列表(Hash table,也叫哈希表),是根据键(Key)而直接访问在内存储存位置的数据结构 也就是说,它通过计算一个关于键值的函数,将所需查询的数据映射到表中一个位置来访问记录,这加快了查找速度.这个映射函数称做散列函数,存放记录的数组称做散列表 举例说明为了查找电话簿中某人的号码,可以创建一个按照人名首字母顺序排列的表(即建立人名x到首字母F(x)的一个函数关系),在首字母为W的表中查找“王”姓的电话号码,显然比直接查找就要快得多 这里使用人名作为关键字,“取首字母”是这个例子中散列函数的函数法则F(),存放首字母的表对应散列表.关键字和函数法则理论上可以任意确定 散列函数(哈希函数)通过上面例子,我们可以把散列函数比喻成一个中转站,它可以帮助我们将key转化为数组的下标 而哈希表本质上就是一个数组,通过散列函数,我们可以极其快速的查询到key值所对应的信息 哈希冲突 开放寻址法 开发寻址法就是但我们遇到了哈希冲突,我们就重新探索一个空闲位置,然后插入 链地址法 采用数组和链表相结合的办法,将Hash地址相同的记录存储在一张线性表中,而每张表的表头的序号即为计算得到的Hash地址 相关资料 Java中散列表在Java中,散列表使用链表数组实现(也就是链地址法),而每个列表被称为桶(bucket) 想要查询表中对像的位置,就要先计算它的散列码(hash code),然后于桶的总数取余,所得到的结果就是保存这个元素桶的索引 hashCode()方法是定义在Object中,所以所有的对象都有此方法 举例说明例如,某个对象的散列码(调用对象的hashCode方法的返回值)为76268,并且有128个桶,那么对象就应该保持在第108号桶中(76268除以128余108) 或许会很幸运,在这个桶中没有其他元素,此时将元素直接插入到桶中就可以了 当然,有时候会遇到桶被占满的情况,这也是不可避免的.这种情况叫散列冲突 那么这时,就需要用新对象与桶中的所有对象逐个进行对比(调用对象的equals()),查看这个对象是否存在 重写equals就必须重写hashCode,具体查看hashCode笔记 如果散列码是合理且随机分布,同时桶的数目也够大,需要比较的次数就会很少 扩容标准库使用的桶数是2的幂,默认值为16(为表大小提供任何职都将被自动地转换为2的下一个幂) 如果散列表太满,就需要再散列(rehashed).如果要对散列表在散列,就需要创建一个桶数更多的表,并将所有的元素插入到这个新表中,然后丢弃原来的表 装填因子(load factor)决定合适对散列表进行再散列 例如.如果装填因子为0.75(默认值),而表中超过75%的位置已经填入元素,这个表就会用双碑的桶数自动的进行再散列 对大多数应用程序来说,装填因子0.75是比较合理的 注意点想要更多地控制散列表的运行性能,就要指定一个初始的桶数 桶数是指用于收集有相同散列值的数目.如果要插入到散列表中的元素太多,就会增加冲突的可能性,降低运行性能 如果大致知道最终会有多少个元素要插入到散列表中,就可以设置桶数.通常将桶数设置为预计元素个数的75% ~ 150% 存在散列表中的对象,必须要重写hashCode和equals方法 在Java8中,桶中元素大于8并且桶大于等于64时,会从链表变成平衡二叉树(红黑树) 优缺点散列表的缺点是无法控制元素出现的次序,优点是能高效的查找,时间复杂度接近O(1) Set (集)Set: 储存无序的、不可重复的数据.Set接口并没有添加新的方法,所有的方法都继承自Collection接口 无序性: 不等于随机性,储存的数据在底层数组中并非按照数组索引添加,而是根据数据的(散列码)哈希值决定的 其实底层使用的时HashMap,HashMap底层是数组.关于这部分知识可以查看后面的HashMap 不可重复性: 保证添加的元素按照equals()判断时,不能返回true,即.相同的元素只能添加一个 Set接口下主要有四个主要的实现类 HashSet(常用) 为快速查找而设计的Set它是实现了散列表的集.存入HashSet的元素必须定义hashCode() 内部使用HashMap LinkedHashSet 它是HashSet的子类,具有HashSet的查询速度,同时内部使用链表维护元素的顺序(插入的顺序).元素也必须定义hashCode() 它并没有添加额外的方法,只是在构造时,使用LinkedHashMap.关于这部分知识可以查看后面的LinkedHashMap TreeSet 它与散列集十分类似,不过,它比散列集有所改进. 树集是一个有序集合可以以任意顺序将元素插入到集合中.在对集合进行遍历时,每个值将自动地按照排序后的顺序呈现 它与散列集不同,它并不是使用equals()来判断两个元素是否相同,而是使用Comparable、Comparator来判断是否相同 所以要使用它,必须能够比较元素.这些元素必须实现Comparable接口或者构造集时必须提供一个Comparator 需要注意一点: 当Comparable,Comparator同时存在时,使用给定的Comparator规则 同样TreeSet内部也同样使用TreeMap EnumSet 它是一个枚举类型元素集的高效实现 使用的不多,这里不做介绍.需要了解的话参考 总结HashSet在使用它之前需要重写equals和hashCode方法,否则他还是会储存重复的元素,一般情况下还是用它 LinkedHashSet它则可以记住添加元素的顺序.如果需要想添加时没有重复的元素而且记住添加时元素的顺序,那么可以使用它 TreeSet在使用它之前则需要有一个排序的规则Comparable、Comparator都可以.它会帮你在添加的时候自动排序 Queue (队列)队列是一种线性数据结构,队列中的元素只能先入先出(First In First Out,简称FIFO) 队列可以让人们有效地在尾部添加一个元素,在头部删除一个元素 下面是在Queue的接口的方法: 12345678910111213141516171819202122232425262728293031323334353637public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; /** * 如果可以在不违反容量限制的情况下立即将指定的元素插入到此队列中， * 如果成功则返回`true`,如果当前没有可用空间则抛出`IllegalStateException` */ boolean add(E e); /** * 如果可以在不违反容量限制的情况下立即将指定的元素插入到此队列中 * 当使用容量受限的队列时,此方法通常比`add`更可取,因为`add`可能通过抛出异常而无法仅插入元素 * 如果元素被添加到此队列返回`true`否则返回`false` */ boolean offer(E e); /** * 检索并删除此队列的头.这个方法与`poll`的不同之处在于,它只在这个队列为空时抛出一个异常。 * 如果这个队列是空的,则抛出`NoSuchElementException` */ E remove(); /** * 检索并删除此队列的头,如果此队列为空,则或返回null */ E poll(); /** * 检索但不删除此队列的头.此方法与`peek`唯一的区别在于,如果此队列为空,它将抛出一个异常。 * 如果这个队列是空的,则抛出`NoSuchElementException` */ E element(); /** * 检索此队列的头,但不删除它,如果此队列为空,则或返回null */ E peek();&#125; 队列最要在并发容器中使用这里不多做介绍 Map(映射)Map: 存储键、键值对组合的集合,提供了key到Value的映射.Map并没有继承Collection而是与他一样都是根接口 在Map中它保证了key与value之间的一一对应关系.也就是说一个key对应一个value,所以它不能存在相同的key值,当然value值可以相同 HashMap (常用) HashMap是基于哈希表的实现,也就是说它既有Map的键值对特点,也有哈希表的特点 HashSet底层是HashMap,所以HashSet底层只要使用它就可以完成所需要的功能 HashMap是线程不安全的.key可以为null,value也可以为null Hashtable Hashtable是JDK1.0提供的一个类,现在不推荐使用 Hashtable是线程安全的.key不可以为null,value也不可以为null TreeMap 同样它与TreeSet一样,不过TreeSet内部使用的是TreeMap.它是对key进行排序 同理要使用它,必须能够比较元素.这些元素必须实现Comparable接口或者构造集时必须提供一个Comparator LinkedHashMap LinkedHashSet和LinkedHashMap类一样,它们都可以记住插入元素的顺序 同样的LinkedHashMap也是HashMap的子类 它在Node类内部增加两个字段before, after来记住上一个元素和下一个元素,所以LinkedHashSet内部使用来它达到记住元素顺序的目的 WeakHashMap WeakHashMap使用WeakReference类型来保存键.如果垃圾回收器发现某个特定对象已经没人他人引用了,就将其回收 相关资料 EnumMap 它是一个键类型为枚举类型的映射,它可以直接且高效地用一个值数组实现 在使用时,需要在构造器中指定键类型 使用的也很少,需要了解的话参考 IdentityHashMap 它与HashMap不同它使用==来判断对象是否相同 相关资料 视图与包装器视图是一个轻量级的对象,它实现了Collection或者Map接口,但从传统意义上来说并不是真正的集合 视图根本不包含其自己的数据.它的所有操作都是根据对另一个对象的操作实现 例如: Map类中的keySet()方法就是一个这样的实例 看起来给人的感觉就是这个方法创建了一个Set,并将Map中的所有键都添加进去,然后返回.但是,实际情况并不是如此 取而代之的是,keySet()返回一个实现Set接口的类型对象.这个类的方法对原Map进行操作 具体调用代码 12345678public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; if (ks == null) &#123; ks = new KeySet(); keySet = ks; &#125; return ks;&#125; 返回KeySet对象,这个对象继承了AbstractSet接口,同时iterator()方法返回一个KeyIterator类 1234567891011121314151617181920212223242526final class KeySet extends AbstractSet&lt;K&gt; &#123; public final int size() &#123; return size; &#125; public final void clear() &#123; HashMap.this.clear(); &#125; public final Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public final boolean contains(Object o) &#123; return containsKey(o); &#125; public final boolean remove(Object key) &#123; return removeNode(hash(key), key, null, false, true) != null; &#125; public final Spliterator&lt;K&gt; spliterator() &#123; return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0); &#125; public final void forEach(Consumer&lt;? super K&gt; action) &#123; Node&lt;K,V&gt;[] tab; if (action == null) throw new NullPointerException(); if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123; int mc = modCount; for (int i = 0; i &lt; tab.length; ++i) &#123; for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) action.accept(e.key); &#125; if (modCount != mc) throw new ConcurrentModificationException(); &#125; &#125;&#125; 可以看到这里是直接调用拿Map中Node对象的key遍历 1234final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; &#123; public final K next() &#123; return nextNode().key; &#125;&#125; StackOverflow上关于视图的问题 CSDN相关文章 轻量级集合包装器Arrays类的静态方法asList将返回一个包装了普通Java数组的List包装器 这个方法可以将数组传递给一个期望得到列表或集合参数的方法 12String[] strArray = new String[]&#123;\"a\", \"b\", \"c\"&#125;;List&lt;String&gt; list = Arrays.asList(strArray); 返回的对象不是ArrayList(虽然它也叫ArrayList) 它是一个视图对象,带有访问底层数组的get和set方法 特别注意: 改变数组大小的所有方法(例如,迭代器相关的add和remove方法)都会抛出一个UnsupportedOperationException异常 另外该方法还可以接受可变长参数 1List&lt;String&gt; list = Arrays.asList(\"a\", \"b\", \"c\"); asList方法具体代码 123public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 这里的ArrayList并不是java.util.ArrayList.它只是Arrays类中的一个内部类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125; @Override public int size() &#123; return a.length; &#125; @Override public Object[] toArray() &#123; return a.clone(); &#125; @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T[] toArray(T[] a) &#123; int size = size(); if (a.length &lt; size) return Arrays.copyOf(this.a, size, (Class&lt;? extends T[]&gt;) a.getClass()); System.arraycopy(this.a, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; @Override public E get(int index) &#123; return a[index]; &#125; @Override public E set(int index, E element) &#123; E oldValue = a[index]; a[index] = element; return oldValue; &#125; @Override public int indexOf(Object o) &#123; E[] a = this.a; if (o == null) &#123; for (int i = 0; i &lt; a.length; i++) if (a[i] == null) return i; &#125; else &#123; for (int i = 0; i &lt; a.length; i++) if (o.equals(a[i])) return i; &#125; return -1; &#125; @Override public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(a, Spliterator.ORDERED); &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); for (E e : a) &#123; action.accept(e); &#125; &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); E[] a = this.a; for (int i = 0; i &lt; a.length; i++) &#123; a[i] = operator.apply(a[i]); &#125; &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; Arrays.sort(a, c); &#125; &#125; Collections.nCopies(n, anObject)方法将返回一个实现了List接口的不可修改的对象,并给人一种包含N个元素的,每个元素都像是一个anObject的错觉 例如,创建一个包含100个字符串的List,每个元素都设置为&quot;DEFAULT&quot; 1Collections.nCopies(100, \"DEFAULT\"); 其实内部只有一个元素,而size是100,所以存储的代价很小 查看具体代码 12345 public static &lt;T&gt; List&lt;T&gt; nCopies(int n, T o) &#123; if (n &lt; 0) throw new IllegalArgumentException(\"List length = \" + n); return new CopiesList&lt;&gt;(n, o);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495private static class CopiesList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, Serializable &#123; private static final long serialVersionUID = 2739099268398711800L; final int n; final E element; CopiesList(int n, E e) &#123; assert n &gt;= 0; this.n = n; element = e; &#125; public int size() &#123; return n; &#125; public boolean contains(Object obj) &#123; return n != 0 &amp;&amp; eq(obj, element); &#125; public int indexOf(Object o) &#123; return contains(o) ? 0 : -1; &#125; public int lastIndexOf(Object o) &#123; return contains(o) ? n - 1 : -1; &#125; public E get(int index) &#123; if (index &lt; 0 || index &gt;= n) throw new IndexOutOfBoundsException(\"Index: \"+index+ \", Size: \"+n); return element; &#125; public Object[] toArray() &#123; final Object[] a = new Object[n]; if (element != null) Arrays.fill(a, 0, n, element); return a; &#125; @SuppressWarnings(\"unchecked\") public &lt;T&gt; T[] toArray(T[] a) &#123; final int n = this.n; if (a.length &lt; n) &#123; a = (T[])java.lang.reflect.Array .newInstance(a.getClass().getComponentType(), n); if (element != null) Arrays.fill(a, 0, n, element); &#125; else &#123; Arrays.fill(a, 0, n, element); if (a.length &gt; n) a[n] = null; &#125; return a; &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; if (fromIndex &lt; 0) throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex); if (toIndex &gt; n) throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex); if (fromIndex &gt; toIndex) throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") &gt; toIndex(\" + toIndex + \")\"); return new CopiesList&lt;&gt;(toIndex - fromIndex, element); &#125; // 省略 equals hashcode // Override default methods in Collection @Override public Stream&lt;E&gt; stream() &#123; return IntStream.range(0, n).mapToObj(i -&gt; element); &#125; @Override public Stream&lt;E&gt; parallelStream() &#123; return IntStream.range(0, n).parallel().mapToObj(i -&gt; element); &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return stream().spliterator(); &#125; private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ois.defaultReadObject(); SharedSecrets.getJavaOISAccess().checkArray(ois, Object[].class, n); &#125; &#125; 然而在Collections类中还有类似的几个方法 Collection.singleton(anObject) 这个方法返回一个实现了Set接口视图对象,并且是一个不可修改的单元素Set,这样的花就不需要付出建立数据结构的开销 同样的还有singletonList,singletonMap方法都是一样的 singleton方法具体代码 1234567891011121314151617181920212223242526272829303132private static class SingletonSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Serializable &#123; private static final long serialVersionUID = 3193687207550431679L; private final E element; SingletonSet(E e) &#123;element = e;&#125; public Iterator&lt;E&gt; iterator() &#123; return singletonIterator(element); &#125; public int size() &#123;return 1;&#125; public boolean contains(Object o) &#123;return eq(o, element);&#125; // Override default methods for Collection @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; action.accept(element); &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return singletonSpliterator(element); &#125; @Override public boolean removeIf(Predicate&lt;? super E&gt; filter) &#123; throw new UnsupportedOperationException(); &#125; &#125; Collection.emptyMap(anObject) 这个方法返回一个实现了Map接口视图对象,它的内部没有元素 同样的还有emptySet,emptyList方法都是一样的 子范围视图视图不仅仅全部都是操作所有的数据,它还可以操作部分数据 例如,我们想获取第1~第3个元素.就可以使用subList方法来获得一个列表的子范围视图 12List&lt;String&gt; stringList = new ArrayList&lt;&gt;(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"));List&lt;String&gt; subList = stringList.subList(1, 4); 第一个索引包含在内,第二个索引则不包含在内.这与String类的substring操作中的参数情况相同 可以将任何操作应用于子范围,并且能够自动地反映整个列表的情况例如: 1234List&lt;String&gt; stringList = new ArrayList&lt;&gt;(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"));List&lt;String&gt; subList = stringList.subList(1, 4);subList.clear(); // 清除视图同时其实删除原对象内的元素System.out.println(stringList); 将子范围视图清空后(subList.clear()),相对应的元素自动从stringList中删除,并且subList为空 ArrayList中subList源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final AbstractList&lt;E&gt; parent; private final int parentOffset; private final int offset; int size; SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; public E set(int index, E e) &#123; rangeCheck(index); checkForComodification(); E oldValue = ArrayList.this.elementData(offset + index); ArrayList.this.elementData[offset + index] = e; return oldValue; &#125; public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; public int size() &#123; checkForComodification(); return this.size; &#125; public void add(int index, E e) &#123; rangeCheckForAdd(index); checkForComodification(); parent.add(parentOffset + index, e); this.modCount = parent.modCount; this.size++; &#125; public E remove(int index) &#123; rangeCheck(index); checkForComodification(); E result = parent.remove(parentOffset + index); this.modCount = parent.modCount; this.size--; return result; &#125; protected void removeRange(int fromIndex, int toIndex) &#123; checkForComodification(); parent.removeRange(parentOffset + fromIndex, parentOffset + toIndex); this.modCount = parent.modCount; this.size -= toIndex - fromIndex; &#125; public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(this.size, c); &#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); int cSize = c.size(); if (cSize==0) return false; checkForComodification(); parent.addAll(parentOffset + index, c); this.modCount = parent.modCount; this.size += cSize; return true; &#125; public Iterator&lt;E&gt; iterator() &#123; return listIterator(); &#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123; checkForComodification(); rangeCheckForAdd(index); final int offset = this.offset; return new ListIterator&lt;E&gt;() &#123; int cursor = index; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123; return cursor != SubList.this.size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= SubList.this.size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[offset + (lastRet = i)]; &#125; public boolean hasPrevious() &#123; return cursor != 0; &#125; @SuppressWarnings(\"unchecked\") public E previous() &#123; checkForComodification(); int i = cursor - 1; if (i &lt; 0) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i; return (E) elementData[offset + (lastRet = i)]; &#125; @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; Objects.requireNonNull(consumer); final int size = SubList.this.size; int i = cursor; if (i &gt;= size) &#123; return; &#125; final Object[] elementData = ArrayList.this.elementData; if (offset + i &gt;= elementData.length) &#123; throw new ConcurrentModificationException(); &#125; while (i != size &amp;&amp; modCount == expectedModCount) &#123; consumer.accept((E) elementData[offset + (i++)]); &#125; // update once at end of iteration to reduce heap write traffic lastRet = cursor = i; checkForComodification(); &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor - 1; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; SubList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void set(E e) &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.set(offset + lastRet, e); &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; public void add(E e) &#123; checkForComodification(); try &#123; int i = cursor; SubList.this.add(i, e); cursor = i + 1; lastRet = -1; expectedModCount = ArrayList.this.modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (expectedModCount != ArrayList.this.modCount) throw new ConcurrentModificationException(); &#125; &#125;; &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, offset, fromIndex, toIndex); &#125; private void rangeCheck(int index) &#123; if (index &lt; 0 || index &gt;= this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private void rangeCheckForAdd(int index) &#123; if (index &lt; 0 || index &gt; this.size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; private String outOfBoundsMsg(int index) &#123; return \"Index: \"+index+\", Size: \"+this.size; &#125; private void checkForComodification() &#123; if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); &#125; public Spliterator&lt;E&gt; spliterator() &#123; checkForComodification(); return new ArrayListSpliterator&lt;E&gt;(ArrayList.this, offset, offset + this.size, this.modCount); &#125;&#125; 可以看到它是通过偏移来实现,所有的操作还是使用parent父列表 subList方法在List接口中,而Set、Map接口中并没有这个功能 不过对于有序集和映射,可以使用排序顺序而不是元素位置建立子范围 SoredSet接口声明了三个方法 123SortedSet&lt;E&gt; subSet(E from, E to)SortedSet&lt;E&gt; headSet(E to)SortedSet&lt;E&gt; tailSet(E from) 这些方法将返回大于等于from且小于to的所有元素子集.有序映射也有类似的方法 123SortedMap&lt;K, V&gt; subMap(K from, K to)SortedMap&lt;K, V&gt; headMap(K to)SortedMap&lt;K, V&gt; tailMap(K from) 在JDK1.6引入了NavigableSet和NavigableMap接口赋予子范围操作更多的控制能力.可以指定是否包含边界 NavigableSet、NavigableMap接口详情 NavigableSet接口 123NavigableSet&lt;E&gt; subSet (E from, boolean fromlnclusive, E to, boolean tolnclusive)NavigableSet&lt;E&gt; headSet(E to, boolean tolnclusive)Navigab1eSet&lt;E&gt; tailSet(E from, boolean fromlnclusive) NavigableMap接口 123NavigableMap&lt;K,V&gt; subMap (K from, boolean fromlnclusive, K to, boolean tolnclusive)NavigableMap&lt;K,V&gt; headMap(K to, boolean tolnclusive)Navigab1eMap&lt;K,V&gt; tailMap(K from, boolean fromlnclusive) NavigableSet实现了SortedSet接口,NavigableMap接口也是一样实现了SortedMap接口 参考 不可修改视图Collections还有几个方法用来产生集合的不可修改视图 这些视图对现有集合增加了一个运行时的检查.如果发现试图对集合进行修改,就抛出异常,同时这个集合将保持未修改的状态 主要用途是: 可以查看某个集合内容,但是又能避免这个集合被修改,相当于只读 可以使用过下面8种方法获得不可修改视图 unmodifiableCollection unmodifiableSet unmodifiableSortedSet unmodifiableNavigableSet unmodifiableList unmodifiableMap unmodifiableSortedMap unmodifiableNavigableMap 每个方法都定义与一个接口.例如Collections.unmodifiableList定义的是List接口.可以与ArrayList、LinkedList或者任何实现了List接口的其他类一起协同工作 例如: 123List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"));List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(list);// unmodifiableList.add(\"f\"); // 错误,抛出UnsupportedOperationException异常 Collections.unmodifiableList方法将返回一个实现List接口的类对象(视图对象) 可以从unmodifiableList这个视图对象中获取元素,但是不能修改. 因为所有的修改类型的方法以及被重新定义为一个抛出UnsupportedOperationException的异常,而不是将调用传递到底层集合(在这里指list) 查看UnmodifiableList源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980static class UnmodifiableList&lt;E&gt; extends UnmodifiableCollection&lt;E&gt; implements List&lt;E&gt; &#123; private static final long serialVersionUID = -283967356065247728L; final List&lt;? extends E&gt; list; UnmodifiableList(List&lt;? extends E&gt; list) &#123; super(list); this.list = list; &#125; public boolean equals(Object o) &#123;return o == this || list.equals(o);&#125; public int hashCode() &#123;return list.hashCode();&#125; public E get(int index) &#123;return list.get(index);&#125; public E set(int index, E element) &#123; throw new UnsupportedOperationException(); &#125; public void add(int index, E element) &#123; throw new UnsupportedOperationException(); &#125; public E remove(int index) &#123; throw new UnsupportedOperationException(); &#125; public int indexOf(Object o) &#123;return list.indexOf(o);&#125; public int lastIndexOf(Object o) &#123;return list.lastIndexOf(o);&#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; throw new UnsupportedOperationException(); &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; throw new UnsupportedOperationException(); &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; throw new UnsupportedOperationException(); &#125; public ListIterator&lt;E&gt; listIterator() &#123;return listIterator(0);&#125; public ListIterator&lt;E&gt; listIterator(final int index) &#123; return new ListIterator&lt;E&gt;() &#123; private final ListIterator&lt;? extends E&gt; i = list.listIterator(index); public boolean hasNext() &#123;return i.hasNext();&#125; public E next() &#123;return i.next();&#125; public boolean hasPrevious() &#123;return i.hasPrevious();&#125; public E previous() &#123;return i.previous();&#125; public int nextIndex() &#123;return i.nextIndex();&#125; public int previousIndex() &#123;return i.previousIndex();&#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public void set(E e) &#123; throw new UnsupportedOperationException(); &#125; public void add(E e) &#123; throw new UnsupportedOperationException(); &#125; @Override public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; i.forEachRemaining(action); &#125; &#125;; &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; return new UnmodifiableList&lt;&gt;(list.subList(fromIndex, toIndex)); &#125; private Object readResolve() &#123; return (list instanceof RandomAccess ? new UnmodifiableRandomAccessList&lt;&gt;(list) : this); &#125; &#125; 不可修改视图并不是集合本身不可修改.仍然可以通过集合原始的引用(在这里值list)对集合进行修改.同时,原来引用集合的元素发生变化,那么视图对象的元素也会随之变化 参考 同步视图如果由多个线程访问集合,就必须确保集合不会被意外的破坏 例如:如果一个线程试图将元素添加到HashMap中,同时另外一个线程正在对HashMap进行扩容,那么结果将是灾难性的 我们可以使用视图机制来确保常规集合的线程安全,而不是实现线程安全的集合类 例如,Collections类的静态synchronizedMap方法可以将任何一个映射表转换成具有同步访问方法的Map 1Map&lt;String, String&gt; synchronizedMap = Collections.synchronizedMap(new HashMap&lt;&gt;()); 现在,就可以由多线程访问map对象了.像get和put这类方法都是同步操作的,即在另一个线程调用另一个方法之前,刚才的方法调用必须彻底完成 查看SynchronizedMap源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140private static class SynchronizedMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable &#123; private static final long serialVersionUID = 1978198479659022715L; private final Map&lt;K,V&gt; m; // Backing Map final Object mutex; // Object on which to synchronize SynchronizedMap(Map&lt;K,V&gt; m) &#123; this.m = Objects.requireNonNull(m); mutex = this; &#125; SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123; this.m = m; this.mutex = mutex; &#125; public int size() &#123; synchronized (mutex) &#123;return m.size();&#125; &#125; public boolean isEmpty() &#123; synchronized (mutex) &#123;return m.isEmpty();&#125; &#125; public boolean containsKey(Object key) &#123; synchronized (mutex) &#123;return m.containsKey(key);&#125; &#125; public boolean containsValue(Object value) &#123; synchronized (mutex) &#123;return m.containsValue(value);&#125; &#125; public V get(Object key) &#123; synchronized (mutex) &#123;return m.get(key);&#125; &#125; public V put(K key, V value) &#123; synchronized (mutex) &#123;return m.put(key, value);&#125; &#125; public V remove(Object key) &#123; synchronized (mutex) &#123;return m.remove(key);&#125; &#125; public void putAll(Map&lt;? extends K, ? extends V&gt; map) &#123; synchronized (mutex) &#123;m.putAll(map);&#125; &#125; public void clear() &#123; synchronized (mutex) &#123;m.clear();&#125; &#125; private transient Set&lt;K&gt; keySet; private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; private transient Collection&lt;V&gt; values; public Set&lt;K&gt; keySet() &#123; synchronized (mutex) &#123; if (keySet==null) keySet = new SynchronizedSet&lt;&gt;(m.keySet(), mutex); return keySet; &#125; &#125; public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; synchronized (mutex) &#123; if (entrySet==null) entrySet = new SynchronizedSet&lt;&gt;(m.entrySet(), mutex); return entrySet; &#125; &#125; public Collection&lt;V&gt; values() &#123; synchronized (mutex) &#123; if (values==null) values = new SynchronizedCollection&lt;&gt;(m.values(), mutex); return values; &#125; &#125; public boolean equals(Object o) &#123; if (this == o) return true; synchronized (mutex) &#123;return m.equals(o);&#125; &#125; public int hashCode() &#123; synchronized (mutex) &#123;return m.hashCode();&#125; &#125; public String toString() &#123; synchronized (mutex) &#123;return m.toString();&#125; &#125; // Override default methods in Map @Override public V getOrDefault(Object k, V defaultValue) &#123; synchronized (mutex) &#123;return m.getOrDefault(k, defaultValue);&#125; &#125; @Override public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123; synchronized (mutex) &#123;m.forEach(action);&#125; &#125; @Override public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) &#123; synchronized (mutex) &#123;m.replaceAll(function);&#125; &#125; @Override public V putIfAbsent(K key, V value) &#123; synchronized (mutex) &#123;return m.putIfAbsent(key, value);&#125; &#125; @Override public boolean remove(Object key, Object value) &#123; synchronized (mutex) &#123;return m.remove(key, value);&#125; &#125; @Override public boolean replace(K key, V oldValue, V newValue) &#123; synchronized (mutex) &#123;return m.replace(key, oldValue, newValue);&#125; &#125; @Override public V replace(K key, V value) &#123; synchronized (mutex) &#123;return m.replace(key, value);&#125; &#125; @Override public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) &#123; synchronized (mutex) &#123;return m.computeIfAbsent(key, mappingFunction);&#125; &#125; @Override public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; synchronized (mutex) &#123;return m.computeIfPresent(key, remappingFunction);&#125; &#125; @Override public V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; synchronized (mutex) &#123;return m.compute(key, remappingFunction);&#125; &#125; @Override public V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123; synchronized (mutex) &#123;return m.merge(key, value, remappingFunction);&#125; &#125; private void writeObject(ObjectOutputStream s) throws IOException &#123; synchronized (mutex) &#123;s.defaultWriteObject();&#125; &#125; &#125; 底层的方法都加上了synchronized.实际方法还是调用底层对象m 同样获得同步视图也是8种方法 synchronizedCollection synchronizedSet synchronizedSortedSet synchronizedNavigableSet synchronizedList synchronizedMap synchronizedSortedMap synchronizedNavigableMap 检查视图“受査”视图用来对泛型类型发生问题时提供调试支持 1234LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();List rawList = list;rawList.add(LocalDate.now());list.getFirst(); // 抛出异常 java.lang.ClassCastException 这个错误的add,在运行时检测不到.相反,只要调用get方法,将结果转化为String时,就会抛出ClassCastException异常 而受检视图可以探测到这类问题 123List&lt;String&gt; stringList = Collections.checkedList(new LinkedList&lt;&gt;(), String.class);rawList = stringList;rawList.add(LocalDate.now()); //在添加时即可探测类型问题,而不是等到获取时 视图的add方法将检测插人的对象是否属于给定的类.如果不属于给定的类,就立即抛出一个 ClassCastException.这样做的好处是错误可以在正确的位置得以报高 查看解析 视图对象CheckedList再添加时调用typeCheck方法来对类型做检查 123public void add(int index, E element) &#123; list.add(index, typeCheck(element));&#125; 具体类型检查代码如下: 12345E typeCheck(Object o) &#123; if (o != null &amp;&amp; !type.isInstance(o)) throw new ClassCastException(badElementMsg(o)); return (E) o;&#125; 有9个方法可以得到受查视图 checkedCollection checkedQueue checkedSet checkedSortedSet checkedNavigableSet checkedList checkedMap checkedSortedMap checkedNavigableMap 受查视图受限于虚拟机可以运行的运行时检查.例如,对于ArrayList&lt;Pair&lt;String&gt;,由于虚拟机有一个单独的”原始”Pair类,所以,无法阻止插入Pair&lt;Date&gt; 不可变视图、同步视图、检查视图注意点 unmodifiableCollection、synchronizedCollection、checkedCollection这几个方法返回都是视图,但是它们的equals方法不调用底层集合的equals的方法 相反,它继承了Object类的equals方法,这个方法只是检测两个对象是否是同一个对象(也就是直接对比引用的地址,使用==) 然而unmodifiableSet和unmodifiableList却使用底层集合的equals方法和hashCode 算法排序与混排 排序 Collections类中的sort方法可以对实现了List接口的集合进行排序 12345678List&lt;Employee&gt; linkedList = new LinkedList&lt;&gt;();linkedList.add((Employee.of(\"li\", 10000d, LocalDate.of(1996, 2, 1))));linkedList.add((Employee.of(\"zhang\", 9500d, LocalDate.of(1995, 1, 1))));linkedList.add((Employee.of(\"chen\", 10000d, LocalDate.of(1996, 6, 4))));linkedList.add((Employee.of(\"wang\", 5000d, LocalDate.of(1996, 6, 6))));// 根据Comparable来排序Collections.sort(linkedList); 使用Collections.sort方法必须要元素实现了Comparable接口才可以,否则的话则需要使用重载方法,传入Comparator对象 如果想采用其他方式排序(或者元素没有实现Comparable接口),可以使用List接口的sort方法并传入一个Comparator对象 12// 根据工资自然排序linkedList.sort(Comparator.comparingDouble(Employee::getSalary)); 如果想按照降序排序,可以使用一种比较方便的静态方法Collections.reverseOrder() 12// 倒序排序linkedList.sort(Comparator.reverseOrder()); 或者使用Comparator类的reversed方法 12// 根据生日倒序排序linkedList.sort(Comparator.comparing(Employee::getBirthday).reversed()); 混排 Collections类中的shuffle方法,它能随机的混排列表中的元素顺序 如果提供的列表没有实现Randomaccess接口,shuffle方法将元素复制到数组中,然后打乱数组元素的顺序,最后再将打乱顺序后的元素复制回列表 二分查找要想在数组中查找一个对象,通常要一次访问数组中的每个元素,知道找到匹配的元素为止 如果数组是有序的,就可以直接查看位于数组中间的元素,看一看是否大于要查看的元素 如果是,用同样的方法在数组的前半部分继续查找;否则,同样的方法在数组的后半部分继续查找.这样就可以将查找范围缩减一半 要使用二分查找,首先数组必须是有序的(自然顺序,不可使用倒序),否则算法将返回错误的答案 例如,如果数组有1024个元素 二分查找 可以在10次比较后定位所匹配的元素(或者可以确定在数组中不存在这样的元素) 线性查找 如果元素存在,平均需要512次比较;如果元素不存在需要1024次比较才可以确定 Collections类的binarySearch方法实现了这个算法.(注意: 集合必须是要排好序的) 要想查找某个元素,必须提供一个实现List接口的集合,以及要查找的元素 如果集合中的元素没有实现Comparable接口,就还要提供一个比较器对象(Comparator) 12int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key)int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c) 如果binarySearch方法返回的数值大于等于0,则表示匹配对象的索引 如果返回负值,则表示没有匹配的元素.但是,可以利用返回值计算应该将key插入到集合的哪个位置,以保持集合的有序性 插人的位置是-i - 1,调用c.add(-i - 1, key)将元素插入到正确位置 123456789List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(Arrays.asList(4, 5677, 888, 33123, 44,44, 32, 45, 1, 4666));// 排序,自然顺序arrayList.sort(Comparator.naturalOrder());int i = Collections.binarySearch(arrayList, 55);// 没有找到元素if(i &lt; 0) &#123; // 将元素添加的list中 arrayList.add(-i - 1, 55);&#125; 注意集合必须使用自然排序,使用倒序的话查找数据将是错误的 只有采用随机访问(实现了RandomAccess接口的类),二分查找才有意义. 如果必须利用迭代方式一次次地遍历链表的一般元素来找到中间位置的元素,二分查找就完全失去了优势 因此,如果为binarySearch算法提供一个链表,那么它将自动的变为线性查找 简单算法Collections中有许多简单且很有用的算法例如: fill 将列表中所有位置设置为相同的值 copy 原列表中的所有元素复制到目辱列表的相应位置上 addAll 将所有的值添加到集合中(追加元素) reverse 逆置列表中元素的顺序 swap 交换给定偏移量的两个元素 disjoint 判断两个集合是否有不相同的元素 frequency 获取列表中指定元素相同的个数 indexOfSubList、lastIndexOfSubList 返回子集在列表中出现的索引第一次、最后一次出现的位置 rotate 旋转列表中的元素 批操作很多操作会”成批”复制或删除元素 12345// 将从list1中删除list2中出现的所有元素 - 叉集List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5));List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(Arrays.asList(3, 4, 5));list1.removeAll(list2);System.out.println(list1); 12345// 将从list1中保留list2中出现的所有元素 - 交集list1 = new ArrayList&lt;&gt;(Arrays.asList(1, 2, 3, 4, 5));list2 = new ArrayList&lt;&gt;(Arrays.asList(3, 4, 5, 6));list1.retainAll(list2);System.out.println(list1); 集合与数组的转换由于Java平台的大部分内容都是在集合框架创建之前设计的,所以,有时候需要在传统数组和比较现代的集合之间进行转换 如果需要将一个数组转换为集合,Arrays.asList包装器可以达到这个目的 1HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(Arrays.asList(\"1\",\"2\",\"3\")); 而从集合得到数组会困难一些,当然可以使用toArray方法 123HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(Arrays.asList(\"1\",\"2\",\"3\"));Object[] objects = hashSet.toArray(); // 结果是一个对象数组,不能改变它的类型// String[] objects = (String[])hashSet.toArray(); // 错误,不能做强制类型转换 toArray方法返回的数组是一个Object[]数组,不能改变它的类型. 实际上,必须使用toArray方法的一个重载方法,提供一个所需类型而且长度为0的数组*,这样一来,返回的数组就会创建为相同的数组类型 123HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(Arrays.asList(\"1\",\"2\",\"3\"));String[] stringArray = hashSet.toArray(new String[0]);System.out.println(Arrays.toString(stringArray)); 如果愿意,还可以构造一个指定大小的数组 为什么不直接用一个Class对象(例如String.class)传递到toArray方法. 原因是这个方法有”双重职责”,不仅要填充一个已有的数组(如果它足够长),还要创建一个新数组 简单点说就是如果传入的数组长度够用(可以传入指定大小的数组)就不用创建,否则就需要创建新的数","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[]}],"categories":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/categories/nginx/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"SpringSecurity","slug":"SpringSecurity","permalink":"http://yoursite.com/tags/SpringSecurity/"},{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]}